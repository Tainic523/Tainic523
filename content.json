{"pages":[],"posts":[{"title":"博客搭建","text":"概述：使用github搭建博客 一：本地运行1：新建Github博客仓库在github上新建一个repository，仓库名字取做 github名字.github.io 例如：Tainic523.github.io 其他都不用动，直接创建。 2：安装Node.js请移步至 https://nodejs.org/zh-cn/download/ 下载安装 3：安装HEXOwindows用户打开CMD 输入以下命令进行安装 1npm install -g hexo-cli 安装完成之后可以输入 hexo 验证是否安装成功 4：初始化Hexo1hexo init 项目名 执行完毕后，在c盘-&gt;用户-&gt;用户名-&gt;项目名 路径下寻找项目文件 5：编译Hexo项目进入项目文件夹之后打开CMD输入 1hexo generate 6:本地运行Hexocmd输入 1hexo serve 7：查看效果http://localhost:4000 二：部署到Github上1：安装插件进入博客项目文件所在目录打开cmd输入 1npm install hexo-deployer-git --save 2：修改配置文件找到项目文件夹下的_config.yml文件并寻找到deploy字段 1234deploy: type: git repo: git@github.com: github名字/ github名字.github.io.git branch: master 3：执行部署1hexo deploy 等待十分钟过后访问 github名字.github.io","link":"/2019/12/18/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"title":"秋招算法题","text":"概述：秋招常见算法题Java实现 https://github.com/Tainic523/DatabaseAndSort 1：annotation注解使用annotation注解实现自动获取类信息，注解还可用于日志打印，切面等功能。 2：ConsumerAndProducer实现了常见的并发题目，包括死锁，互斥示例，阻塞队列，生产者消费者等。 2.1：AwaitSignalExample使用java并发包里面的 ReentrantLock 和 Condition 实现了互斥示例。 2.2： WaitNotifyCase使用object对象自带的wait和notify方法实现了互斥。 2.3 ：BlockingQueueExample使用LinkedList 实现了带有 阻塞的put 和 take 方法的 阻塞队列BlockingQueueExample，这个类只能存放object的对象。默认队列大小为10，构造函数可以修改阻塞队列大小。 2.4：BlockingQueueImpl使用LinkedList 和泛型 实现了带有 阻塞的put 和 take 方法的 阻塞队列，默认队列大小为10，构造函数可以修改阻塞队列大小。 2.5：ConsumerAndProducer使用 BlockingQueueImpl 实现了生产者和消费者。这里生产者和消费者线程使用的是继承 Thread 类实现的。 2.6：cyclicbarrierTestjava同步互斥工具类CyclicBarrier和CountDownLatch的测试，CyclicBarrier特点可以循环使用，CountDownLatch只可以使用一次。 2.7：DeadLockTest死锁示例，使用object对象自带的wait和notify实现死锁。 2.8：ProducerAndConsumer同样是使用 BlockingQueueImpl 实现了生产者和消费者，这里的线程是通过实现Runnable借口来完成的。 2.9：Singleton单例模式的实现，使用双重锁方式实现，线程安全。 3：DynamicProxyJDK动态代理实现。 4：graph图的相关算法，包括深度遍历，广度遍历，图使用邻接矩阵方式存储。 5：java_iojava读取文件操做 6：leetcode6.1：solution计算回文子串的数目，例：abba 中回文子串数目为1 6.2：Solution650leetcode第650题的解答 7：LRUCache7.1：LRU使用HashMap，泛型，实现LRU队列。常规方式 7.2：LRUCache使用LinkedHashMap 实现LRU队列。最简单的方式 7.3：LRUImpl使用LinkedHashMap ，List，泛型 实现LRU队列，最复杂方式。 8：model使用mybaits进行数据库连接，需要mysql数据库支持。还有Redis的测试。 9：Sort数字和字符串排序算法实现 9.1：sorttest常见数字排序算法实现，包括快排，希尔排序，插入排序，选择排序，堆排序等。 9.2：StringSolution常见字符串相关算法，包括字符串全排列，字符串的全组合，寻找最长公共子串，左旋n位字符串，最长回文子串，回文子串数目。 10：ThreadPool多线程相关实现，包括线程池，信号量等。 10.1：MultiThread多线程示例。 10.2：SemaphoreExample信号量实现同步互斥，10个任务争夺3个资源。 10.3：ThreadExcutor自己实现的线程池。 10.4：Threadimplrment使用10.3实现的线程池跑任务的示例。 10.5：ThreadPoolTest线程池示例。 10.6：ThreadTest如何创建线程。 11：Tree树相关算法，包括遍历，是否相似，求深度，广度，最短路径，镜像树，树的节点数目等。 11.1：TreeNode树的节点定义，以及树的相关算法。 11.2：Serialize树的序列化和反序列化 11.3：Main树的构造和算法测试。","link":"/2019/12/19/%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"title":"字节跳动面经","text":"概述：字节跳动面经 一面 :手写算法:1：实现一个死锁: 2：以O(1)时间复杂度取得最小值的栈，要求有pop， push， getMin方法 问题：1： TCP三次握手加一次变成四次握手有什么问题？2： 浏览器输入网址之后发生了什么？3： 数据库引擎Mylsam,Innodb的区别，4： 数据库行锁表锁，什么时候会加锁?5： 查询语句是否用到索引的分析。6： RocketMQ消息队列原理，单机性能多少？ 为什么这么快？7： RocketMQ如何支持事务的？8： 实习项目的问题，为什么要用当前的模型？有没有更好的模型可以选择？为什么不用更好的？ 二面:手写算法:1：给一个字符串数组，统计每一个字符串出现的次数，要求不能用Set,Map.时间复杂度O(n). 2：实现一个阻塞队列，考虑到多线程并发的情况，要求有put,get,isEmpty, isFull方法。 问题：1: Hashmap底层实现，链表过长会做什么操作？红黑树高度过高会做什么操作？2: Synchronized 和 Reentrantlock区别和底层实现。3: 浏览器输入网址之后发生了什么？4: Cookie,Session相关的知识。5: 一致性哈希原理，负载均衡算法。6: 正向代理，反向代理。7: Redis为什么这么快？ 高并发如何处理的？ 三面:手写算法:1:反转二叉树 场景题:1 索引设计: 一个表有三个字段A,B,C 常用查询语句有 select .. from table where B=..and C= .. select .. from table where A=..and B= .. select .. from table where B=.. 说明如何建立索引以及原因 2 设计一个短链接服务： 短信中的短网址点开之后变成完整的url，完整的url转成短网址发送到用户短信中。整体流程设计。 3 大数据问题： 给两个文件a，b。 a大小为3T, b大小为2T，a中存储的是id 和 name ，b中存储的是id和title，计算机内存2g，要求用最快的方法找出a和b的id重合的部分，输出文件c，c中存储的是id,name,title。 注 id是 varchar 32.","link":"/2019/12/19/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E7%BB%8F/"},{"title":"Github 添加本地SSH公钥","text":"概述：Github 添加本地SSH公钥 1、首先需要检查你电脑是否已经有 SSH key运行 git Bash 客户端，输入如下代码： 12$ cd ~/.ssh$ ls 这两个命令就是检查是否已经存在 id_rsa.pub 或 id_dsa.pub 文件，如果文件已经存在，那bash客户端内应该含有如图所示的文件。那么你可以跳过步骤2，直接进入步骤3。 2、创建一个 SSH key1$ ssh-keygen -t rsa -C \"your_email@example.com\" 代码参数含义： -t 指定密钥类型，默认是 rsa ，可以省略。-C 设置注释文字，比如邮箱。-f 指定密钥文件存储文件名。 以上代码省略了 -f 参数，因此，运行上面那条命令后会让你输入一个文件名，用于保存刚才生成的 SSH key 代码，如： 12Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 当然，你也可以不输入文件名，直接回车，那git就会使用默认文件名（推荐），那么就会生成 id_rsa 和 id_rsa.pub 两个秘钥文件。 接着又会提示你输入两次密码（该密码是你向github push文件的时候要输入的密码，而不是github管理者的密码）， 当然，你也可以不输入密码，直接按回车。那么push的时候就不需要输入密码，直接提交到github上了，如： 12Enter passphrase (empty for no passphrase): Enter same passphrase again: 接下来，就会显示如下提示，如： 当你看到上面这段代码的时候，那就说明，你的 SSH key 已经创建成功，你只需要添加到github的SSH key上就可以了。 3、添加你的 SSH key 到 github上面去a、首先你需要拷贝 id_rsa.pub 文件的内容，你可以用编辑器打开文件复制，也可以用git命令复制该文件的内容，如： 1$ clip &lt; ~/.ssh/id_rsa.pub b、登录你的github账号，从右上角的设置（ Account Settings ）进入，然后点击菜单栏的 SSH key 进入页面添加 SSH key。 c、点击 右上角 New SSH key 按钮添加一个 SSH key 。把你复制的 SSH key 代码粘贴到 key 所对应的输入框中，记得 SSH key 代码的前后不要留有空格或者回车。当然，上面的 Title 所对应的输入框你也可以输入一个该 SSH key 显示在 github 上的一个别名。默认的会使用你的邮件名称。 填写完成之后点击 Add SSH key，这样就成功把你本地的SSH公钥添加到github上啦，添加完成之后你就可以通过本地github的bash窗口的命令行来从github上clone文件到你自己的电脑上。 4、测试一下该SSH key在git Bash 中输入以下代码 1$ ssh -T git@github.com 当你输入以上代码时，会有一段警告代码，如： 123The authenticity of host 'github.com (207.97.227.239)' can't be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 这是正常的，你输入 yes 回车既可。如果你创建 SSH key 的时候设置了密码，接下来就会提示你输入密码，如： 1Enter passphrase for key '/c/Users/Administrator/.ssh/id_rsa': 当然如果你密码输错了，会再要求你输入，知道对了为止。 注意：输入密码时如果输错一个字就会不正确，使用删除键是无法更正的。 密码正确后你会看到下面这段话，如： 1Hi username! You've successfully authenticated, but GitHub does not provide shell access. 最后，你就可以愉快的从github上clone你想要的东西啦！","link":"/2019/12/23/Github-%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0SSH%E5%85%AC%E9%92%A5/"},{"title":"Elasticsearch + Kibana + elasticsearch-head 环境搭建","text":"概述：Elasticsearch 以及其可视化使用工具Kibana和elasticsearch-head的环境搭建 一：背景知识1：Elasticsearch (ES)Elasticsearch是一个分布式、高扩展、高实时的搜索与数据分析引擎。它能很方便的使大量数据具有搜索、分析和探索的能力。充分利用Elasticsearch的水平伸缩性，能使数据在生产环境变得更有价值。Elasticsearch 的实现原理主要分为以下几个步骤，首先用户将数据提交到Elasticsearch 数据库中，再通过分词控制器去将对应的语句分词，将其权重和分词结果一并存入数据，当用户搜索数据时候，再根据权重将结果排名，打分，再将返回结果呈现给用户。 简单来说，Elasticsearch是一个高性能，分布式，高拓展的搜索引擎，提供了比传统数据库更加多样化的数据检索方式，并且在海量数据的情况下Elasticsearch的数据搜索速度远超于传统数据库。 2：KibanaKibana是一个免费且开放的用户界面，能够对 Elasticsearch 数据进行可视化，可以对Elasticsearch进行数据查询，工作中常用到的就是Kibana的 Dev Tools，Dev Tools可以对查询语句进行语法提示，并且会记录历史输入，可以提高工作效率。 3：elasticsearch-headelasticsearch-head和Kibana类似，也是提供了对Elasticsearch进行操作的各种工具，可以清晰的看清Elasticsearch的集群，索引，以及索引的mapping信息，直观的观察集群的负载和健康情况。 二：环境搭建1：安装JDK和Node.js1.1： jdk安装因为ES是使用java实现的，因此需要安装jdk，推荐jdk1.8版本，网上一大堆教程，很简单。安装完之后验证一下就可以。 1.2：Node.js安装Node.js下载连接：https://nodejs.org/zh-cn/download/ 下载完成后打开文件，一路next就可以。 安装完成之后打开CMD验证一下是否安装成功 2：安装ES因为工作使用的ES大版本是6，所以就下载了6.8.0的版本，也可以使用最新的版本，只是要注意的是 Kibana的版本要和ES一致。 2.1：下载windows 版本下载地址：https://www.elastic.co/cn/downloads/past-releases/elasticsearch-6-8-0 PS（翻墙之后下载速度会快一些） 2.2：安装压缩包下载完成之后解压到当前的文件夹，使用win+R键然后输入powershell 之后确定就会打开终端。 然后进入到刚才解压的es文件路径下的bin目录下 执行命令 1.\\elasticsearch.bat 但是最后会报错 ElasticsearchException[X-Pack is not supported and Machine Learning is not available for [windows], ES在6.0版本之后都默认带了 插件，但是windows不支持，因此需要在配置文件config/elasticsearch.yml 中添加一行配置，之后再重新启动。 1xpack.ml.enabled: false 启动成功 然后访问 http://localhost:9200/ 出现如下的返回说明启动ES服务成功。 3：安装KibanaKibana 下载地址：https://www.elastic.co/cn/downloads/past-releases/kibana-6-8-0 和ES一样，下载完毕之后解压到当前路径，打开powershell进入到解压后的文件加的bin目录下，执行 1.\\kibana.bat 等待一会之后，出现如下图所示的语句说明启动成功 然后本地访问 http://localhost:5601 ，出现如下界面。 4：安装elasticsearch-head4.1 chrome插件安装方式 chrome的插件商店提供了elasticsearch-head，如果可以翻墙的话直接在谷歌商店下载然后安装即可。 4.2 手动添加chrome插件方式 如果没办法翻墙的话也可以在github下载，因为这个插件是开源的，可以下载之后在chrome上通过拓展插件的方式安装成功。 下载地址：https://github.com/mobz/elasticsearch-head/blob/master/crx/es-head.crx 下载到本地之后如果直接将crx文件拖拽到Chrome会不能使用，告诉你非Chrome来源的。 要先将crx文件改为以rar结尾的文件，然后再解压到文件夹下。 再通过Chrome“加载已解压的扩展程序”按钮加入文件夹就可以使用了。 添加完毕之后插件列表里会有一个这样的标志。 三：简单使用1：Kibana1.1：导入测试数据首次进入到kibana的界面会提示导入一些由kibana提供样本数据，可以选择把三个样本数据都导入，基本上包含了ES中常用到的数据类型，可以不用自己再构造测试数据了。 1.2：Dev Tools使用kibana左侧选择dev tools 就可以使用kibana提供册查询工具，自带语法提示，能够很大提升工作效率。尤其是在构思一些DSL语句的时候，能够提供很大的帮助。此外，ES的官方文档也是很好的参考手册。 查看集群的索引情况 自带语法提示 2：elasticsearch-headelasticsearch-head 也是工作中常用到的工具，可以很清晰的看到ES集群的健康情况，以及索引的大小，分片数量，以及索引信息等。 创建索引 查看索引信息和状态 四：mac 环境安装ES和kibanamac安装es和kibana相比windows简单的太多了，只要mac的终端安装了homebrew，四行命令就可以了。 1brew install elasticsearch 1brew install kibana 1elasticsearch 1kibana","link":"/2020/11/07/windows%E4%B8%8B-Elasticsearch-+-Kibana-+-elasticsearch-head-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"github","slug":"github","link":"/tags/github/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"秋招","slug":"秋招","link":"/tags/%E7%A7%8B%E6%8B%9B/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"面经","slug":"面经","link":"/tags/%E9%9D%A2%E7%BB%8F/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"技术","slug":"技术","link":"/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Elasticsearch","slug":"Elasticsearch","link":"/tags/Elasticsearch/"},{"name":"kibana","slug":"kibana","link":"/tags/kibana/"},{"name":"elasticsearch-head","slug":"elasticsearch-head","link":"/tags/elasticsearch-head/"}],"categories":[{"name":"github","slug":"github","link":"/categories/github/"},{"name":"工作","slug":"工作","link":"/categories/%E5%B7%A5%E4%BD%9C/"},{"name":"秋招","slug":"秋招","link":"/categories/%E7%A7%8B%E6%8B%9B/"},{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"}]}